---
title: "Trieæœ¨ã®æœ¨æ§‹é€ ã¨LOUDSã®ã‚µã‚¤ã‚ºæ¯”è¼ƒ(Java)"
emoji: "ğŸ“˜"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Java"]
published: false
---

:::message
æœ¬è¨˜äº‹ã¯ [ZOZO Advent Calendar 2021](https://qiita.com/advent-calendar/2021/zozo) ã®2æ—¥ç›®ã®è¨˜äº‹ã§ã™
:::

ã“ã‚“ã«ã¡ã¯ã€[pakio](https://twitter.com/paki0o)ã§ã™ã€‚
ä»Šå›ã®è¨˜äº‹ã¯ã€éå»è‡ªåˆ†ãŒä½•åº¦ã‹ç›®ã‚’èƒŒã‘ã¦æ¥ãŸTrieæœ¨ã«ã¤ã„ã¦ç†è§£ã—ã¤ã¤ã€åŠ¹ç‡çš„ãªå®Ÿè£…ã§ã‚ã‚‹LOUDSã‚‚åŒæ™‚ã«ç†è§£ã—ã‚ˆã†ã¨ã—ãŸå‚™å¿˜éŒ²ã§ã™ã€‚
ä»¥ä¸‹ã‚’å‚è€ƒã«å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
[ç°¡æ½”ãƒ‡ãƒ¼ã‚¿æ§‹é€  LOUDS ã®è§£èª¬ï¼ˆå…¨12å›ã€ç·´ç¿’å•é¡Œä»˜ãï¼‰](https://takeda25.hatenablog.jp/entry/20120421/1335019644)

ä»Šå›ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ã€å…¨ã¦ä»¥ä¸‹ã®ãƒªãƒã‚¸ãƒˆãƒªã«ã¦å…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ã€‚
https://github.com/pakio/Trie-LOUDS

# Trieæœ¨ã«ã¤ã„ã¦
Trieæœ¨ã¯ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒãƒƒãƒã®æ¤œç´¢ã§åˆ©ç”¨ã§ãã‚‹é †åºä»˜ãã®æœ¨æ§‹é€ ã§ã€æ­£è¦è¡¨ç¾ãªã©ã®æ¤œç´¢ã¨æ¯”è¼ƒã—ã¦æ¤œç´¢ã®åŠ¹ç‡åŒ–ãŒè¡Œãˆã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚
æ–‡å­—åˆ—ã‚’1æ–‡å­—1é ‚ç‚¹ã‹ã‚‰æ§‹æˆã•ã‚ŒãŸæœ¨ã¨ã—ã¦è€ƒãˆã€è¤‡æ•°ã®æœ¨ã®ã†ã¡å…ˆé ­ã‹ã‚‰å…±é€šã™ã‚‹é ‚ç‚¹ã‚’å…±æœ‰ã™ã‚‹ã“ã¨ã§å¯¾è±¡ã‚’æ¸›ã‚‰ã—ã€å…ˆé ­ã‹ã‚‰ã®æ¤œç´¢ã‚’åŠ¹ç‡çš„ã«ã—ã¦ã„ã¾ã™ã€‚

è©³ã—ã„èª¬æ˜ã¯ä»¥ä¸‹ã®è¨˜äº‹ãªã©ã‚’å¾¡è¦§ãã ã•ã„ã€‚
https://algo-logic.info/trie-tree/

## Trieã®Javaã§ã®å®Ÿè£…ä¾‹
Javaã§ã®Trieæœ¨ã®æ›´æ–°ç³»å®Ÿè£…ä¾‹ã§ã™ã€‚

```java:Trie.java
public class Trie {
  private Node rootNode;

  public Trie() {
    rootNode = new Node('-');
  }

  public void add(String s) {
    add(s.toCharArray(), 0, rootNode);
  }

  private static void add(char[] chars, int offset, Node node) {
    char key = chars[offset];

    Node childNode;
    if (node.keyExists(key)) {
      childNode = node.getChildNode(key);
    } else {
      childNode = new Node(key);
      node.add(childNode);
    }

    if (chars.length == offset + 1) {
      childNode.setIsLeaf();
      return;
    }

    add(chars, ++offset, childNode);
  }
}
```

```java:Node.java
import java.util.HashMap;
import java.util.Map;

public class Node {
  private final char key;
  private boolean isLeaf;
  private Map<Character, Node> childNodes;

  public Node(char k) {
    key = k;
    childNodes = new HashMap<>();
  }

  public char getKey() {
    return key;
  }

  public void setIsLeaf() {
    isLeaf = true;
  }

  public boolean isLeaf() {
    return isLeaf;
  }

  public void add(Node childNode) {
    childNodes.put(childNode.getKey(), childNode);
  }

  public boolean hasChild() {
    return !childNodes.isEmpty();
  }

  public boolean keyExists(char c) {
    return this.childNodes.containsKey(c);
  }

  public Map<Character, Node> getChildNodes() {
    return childNodes;
  }

  public Node getChildNode(char c) {
    return childNodes.get(c);
  }
}
```

# LOUDSã«ã¤ã„ã¦
LOUDS(Level-Ordered Unary Degree Sequenece)ã¯ã€æœ¨æ§‹é€ ã‚’ã‚ˆã‚ŠåŠ¹ç‡çš„ãªãƒ¡ãƒ¢ãƒªé‡ã§å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’ç›®çš„ã¨ã—ãŸç°¡æ½”ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ã™ã€‚
ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã§ã®æ›´æ–°ãŒå¿…è¦ãªã„å ´åˆ(=æœ¨ã®æ§‹é€ ãŒå›ºå®šã§ã‚ã‚‹å ´åˆ)ã€æœ¨ã‹ã‚‰LOUDSã«å¤‰æ›ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦çœã‚¹ãƒšãƒ¼ã‚¹åŒ–ãŒå¯èƒ½ã§ã™ã€‚
ç´”ç²‹ã«æœ¨æ§‹é€ ã‚’å†ç¾ã™ã‚‹ã ã‘ã§ã‚ã‚Œã°ä»¥ä¸‹ã®è¨˜äº‹ã§ç´¹ä»‹ã•ã‚Œã¦ã„ã‚‹é€šã‚Šç´”ç²‹ãªãƒ“ãƒƒãƒˆåˆ—ã§ã®è¡¨ç¾ã ã‘ã§è¡¨ç¾å¯èƒ½ã§ã™ãŒã€ä»Šå›ã¯æ¤œç´¢ã®ãŸã‚ãã‚Œãã‚Œã®é ‚ç‚¹ãŒå¯¾å¿œã™ã‚‹æ–‡å­—ã€é ‚ç‚¹ãŒè‘‰ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°ã‚‚åˆã‚ã›ã¦ä¿æŒã—ã¾ã™ã€‚
https://takeda25.hatenablog.jp/entry/20120421/1335019644

## LOUDSã®Javaã§ã®å®Ÿè£…ä¾‹
Javaã§Trieæœ¨ã‚’å¤‰æ›ã«LOUDSå¤‰æ›ã™ã‚‹ãŸã‚ã®æœ€ä½é™ã®å®Ÿè£…ã§ã™ã€‚

```java:LOUDS.java
import java.util.ArrayList;
import java.util.List;

public class LOUDS {
  List<Boolean> LBS;
  List<Character> labels;
  List<Boolean> isLeaf;

  public LOUDS () {
    LBS = new ArrayList<>();
    LBS.add(true);
    LBS.add(false);

    labels = new ArrayList<>();
    labels.add(null);
    labels.add(null);

    isLeaf = new ArrayList<>();
    isLeaf.add(false);
    isLeaf.add(false);
  }
}
```

```java:Converter.java
import java.util.ArrayDeque;
import java.util.Map.Entry;
import java.util.Queue;

public class Converter {
  /**
   * convert tree to LOUDS
   */
  public static LOUDS convert(Node rootNode) {
    LOUDS louds = new LOUDS();
    Queue<Node> queue = new ArrayDeque<>();
    queue.add(rootNode);

    while(!queue.isEmpty()) {
      processQueue(queue, louds);
    }

    return louds;
  }

  public static void processQueue(Queue<Node> queue, LOUDS louds) {
    Node node = queue.poll();

    if (node.hasChild()) {
      for(Entry<Character, Node> characterNodeMap : node.getChildNodes().entrySet()) {
        queue.add(characterNodeMap.getValue());
        louds.LBS.add(true);
        louds.labels.add(characterNodeMap.getKey());
        louds.isLeaf.add(characterNodeMap.getValue().isLeaf());
      }
    }

    // end of node
    louds.LBS.add(false);
    louds.isLeaf.add(false);
  }
}
```

# ã‚µã‚¤ã‚ºæ¯”è¼ƒ
LOUDSã®ãƒ¡ãƒªãƒƒãƒˆã¯ã‚µã‚¤ã‚ºãŒå°ã•ããªã‚‹ã“ã¨ã¨è¨˜è¼‰ã—ã¾ã—ãŸãŒã€æœ¬å½“ã«å°ã•ããªã£ã¦ã„ã‚‹ã®ã‹ã€ç´ äººå®Ÿè£…ãªãŒã‚‰è¨ˆæ¸¬ã—ã¦ã¿ã¾ã—ãŸã€‚
è¨ˆæ¸¬ã«ã¯[java-sizeof](https://mvnrepository.com/artifact/com.carrotsearch/java-sizeof)ã‚’ç”¨ã„ã¾ã™ã€‚

è¨ˆæ¸¬ã¯Apache License2.0ã®å…¨æ–‡ã‚’ãƒ‘ãƒ¼ã‚¹ã—ãŸæ–‡å­—åˆ—ã«ã¦è¡Œã„ã¾ã™ã€‚

è¨ˆæ¸¬çµæœã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

```bash:å®Ÿè¡Œçµæœ
Trie size(byte) -> 430328
LOUDS size(byte) -> 62384
```
7åˆ†ã®1ç¨‹åº¦ã§è¡¨ç¾ãŒã§ãã¦ã„ãã†ã§ã™ã€‚

è¨ˆæ¸¬ã«åˆ©ç”¨ã—ãŸã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®ã¨ãŠã‚Šã§ã™ã€‚
```java:Main.java
import com.carrotsearch.sizeof.RamUsageEstimator;
import com.google.common.base.Charsets;
import com.google.common.io.Resources;
import java.io.IOException;
import java.net.URL;
import java.util.StringTokenizer;

public class Main {
  public static void main(String[] args) throws IOException {
    Trie trie = new Trie();

    URL sourceFile = Resources.getResource("LICENSE.txt");
    String targetString = Resources.toString(sourceFile, Charsets.UTF_8);
    String delim = " \n\r\t,.;";
    StringTokenizer st = new StringTokenizer(targetString,delim);
    while (st.hasMoreTokens()) {
      trie.add(st.nextToken());
    }

    LOUDS louds = trie.convert();

    System.out.println("Trie size(byte) -> " + RamUsageEstimator.sizeOf(trie));
    System.out.println("LOUDS size(byte) -> " + RamUsageEstimator.sizeOf(louds));
  }
}
```

# æ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…
ã¤ã„ã§ã«ã€LOUDSã‚’ç”¨ã„ãŸæ¤œç´¢ãƒ­ã‚¸ãƒƒã‚¯ã‚‚å®Ÿè£…ã—ã¾ã—ãŸã€‚

```java:LOUDS.java
import java.util.ArrayList;
import java.util.List;

public class LOUDS {
  List<Boolean> LBS;
  List<Character> labels;
  List<Boolean> isLeaf;

  public LOUDS () {
    LBS = new ArrayList<>();
    LBS.add(true);
    LBS.add(false);

    labels = new ArrayList<>();
    labels.add(null);
    labels.add(null);

    isLeaf = new ArrayList<>();
    isLeaf.add(false);
    isLeaf.add(false);
  }

  public boolean match(String s) {
    return search(2, s.toCharArray(), 0);
  }

  private boolean search(int index, char[] chars, int wordOffset) {
    int charIndex = countTrue(index);
    while(LBS.get(index)) {
      if (chars[wordOffset] == labels.get(charIndex)) {
        if (isLeaf.get(index) && wordOffset + 1 == chars.length) return true;
        else if (wordOffset + 1 == chars.length) return false;
        return search(indexOfLabel(charIndex), chars, ++wordOffset);
      } else {
        index ++;
      }
      charIndex ++;
    }
    return false;
  }

  private int countTrue(int to) {
    return (int)LBS.subList(0, to + 1).stream().filter(elm -> elm).count();
  }

  private int indexOfLabel(int label) {
    int count = 0, i = 0;
    for(; i < LBS.size(); i ++) {
      if (!LBS.get(i)) {
        if (++count == label) {
          break;
        }
      }
    }

    return i + 1;
  }
}
```

æ¤œç´¢çµæœã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```bash:å®Ÿè¡Œçµæœ
match "one" -> true
match "onee" -> false
```

å®Ÿè¡Œã‚³ãƒ¼ãƒ‰ã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚
```java:Main.java
import com.google.common.base.Charsets;
import com.google.common.io.Resources;
import java.io.IOException;
import java.net.URL;
import java.util.StringTokenizer;

public class Main {
  public static void main(String[] args) throws IOException {
    Trie trie = new Trie();

    URL sourceFile = Resources.getResource("LICENSE.txt");
    String targetString = Resources.toString(sourceFile, Charsets.UTF_8);
    String delim = " \n\r\t,.;";
    StringTokenizer st = new StringTokenizer(targetString,delim);
    while (st.hasMoreTokens()) {
      trie.add(st.nextToken());
    }

    LOUDS louds = trie.convert();

    System.out.println("match \"one\" -> " + louds.match("one"));
    System.out.println("match \"onee\" -> " + louds.match("onee"));
  }
}
```

# ã¾ã¨ã‚
Javaã§Trieæœ¨ã®LOUDSã‚’ç”¨ã„ã¦å®Ÿè£…ã—ã¾ã—ãŸã€‚å¤‰æ›å‡¦ç†ãŒéƒ½åº¦å¿…è¦ãªãŸã‚è‹¥å¹²æ‰‹é–“ã¯ã‚ã‚Šãã†ã§ã™ãŒã€ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã«æœ¨ãŒå®Ÿè£…ã§ãã‚‹ã“ã¨ã¯ã‹ãªã‚Šãƒ¡ãƒªãƒƒãƒˆãŒå¤§ããã†ã«æ„Ÿã˜ã¦ã„ã¾ã™ã€‚
æœ¬æ¥ã§ã‚ã‚Œã°ã“ã“ã‹ã‚‰DFSã‚’ç”¨ã„ã¦ã‚µã‚¸ã‚§ã‚¹ãƒˆæ©Ÿèƒ½ã¾ã§å®Ÿè£…ã—ãŸã‹ã£ãŸã¨ã“ã‚ã§ã™ãŒã€ä»Šå›å¶ã‚ãšã ã£ãŸã®ã§ã¾ãŸã®æ©Ÿä¼šã«å®Ÿè£…ã—ã¦ã¿ã¾ã™ã€‚